// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol"; // Provides ownership functionality to the contract
import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol"; // Library for working with ECDSA signatures
import {MessageHashUtils} from "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol"; // Utility for Ethereum-signed message hashes

/**
 * @title ClaimSoftCurrency
 * @dev Contract for managing claims of activity points and coins with signature verification.
 *      Includes functionality for secure backend signature validation.
 */
contract ClaimSoftCurrency is Ownable {
    using ECDSA for bytes32;

    /// @notice Address of the backend signer responsible for generating valid signatures
    address public backendSigner;

    /// @notice Tracks the total points claimed by each address
    mapping(address => uint256) public pointsClaimed;

    /// @notice Tracks the total coins claimed by each address
    mapping(address => uint256) public coinsClaimed;

    /// @notice Tracks the nonce for each address
    mapping(address => uint256) public nonces;

    /// @notice Reverts when the signer of the message is invalid or unauthorized
    error InvalidSigner();

    /// @notice Reverts when the provided signer address is invalid (e.g., zero address)
    error InvalidSignerAddress();

    /// @notice Reverts when the provided points value is zero or invalid
    error InvalidPoints();

    /// @notice Reverts when the provided coins value is zero or invalid
    error InvalidCoins();

    /// @notice Event emitted when currency is successfully claimed
    event CurrencyClaimed(address indexed user, uint256 points, uint256 coins);

    /// @notice Event emitted when the backend signer address is updated
    event BackendSignerChanged(address newBackendSigner);

    /**
     * @dev Constructor initializes the contract with a backend signer address and owner address.
     * @param _backendSigner The address of the backend signer
     * @param _owner The address of the contract owner
     */
    constructor(address _backendSigner, address _owner) Ownable(_owner) {
        if (_backendSigner == address(0)) {
            revert InvalidSignerAddress();
        }

        backendSigner = _backendSigner;
    }

    /**
     * @dev Allows a user to claim currency by providing a valid signature.
     * @param points The number of points to claim
     * @param coins The number of coins to claim
     * @param signature The signature generated by the backend signer
     */
    function claimCurrency(
        uint256 points,
        uint256 coins,
        bytes memory signature
    ) external {
        if (points <= 0) {
            revert InvalidPoints();
        }

        if (coins <= 0) {
            revert InvalidCoins();
        }

        bytes32 messageHash = keccak256(
            abi.encode(
                msg.sender,
                points,
                coins,
                nonces[msg.sender]++,
                block.chainid
            )
        );

        if (!_verifySignature(messageHash, signature)) {
            revert InvalidSigner();
        }

        pointsClaimed[msg.sender] += points;
        coinsClaimed[msg.sender] += coins;

        emit CurrencyClaimed(msg.sender, points, coins);
    }

    /**
     * @dev Updates the backend signer address. Only the contract owner can call this function.
     * @param newSigner The new backend signer address
     */
    function setBackendSigner(address newSigner) external onlyOwner {
        if (newSigner == address(0)) {
            revert InvalidSignerAddress();
        }

        backendSigner = newSigner;

        emit BackendSignerChanged(newSigner);
    }

    /**
     * @dev Verifies the validity of a signature against a message hash.
     * @param messageHash The hash of the message being verified
     * @param signature The signature to verify
     * @return bool True if the signature is valid, false otherwise
     */
    function _verifySignature(
        bytes32 messageHash,
        bytes memory signature
    ) private view returns (bool) {
        bytes32 ethSignedMessageHash = MessageHashUtils.toEthSignedMessageHash(
            messageHash
        );
        return ethSignedMessageHash.recover(signature) == backendSigner;
    }
}
